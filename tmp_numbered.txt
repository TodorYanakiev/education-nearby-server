   1  
package com.dev.education_nearby_server.exceptions.handlers;
   2  

   3  
import com.dev.education_nearby_server.exceptions.common.AccessDeniedException;
   4  
import com.dev.education_nearby_server.exceptions.common.ApiException;
   5  
import com.dev.education_nearby_server.exceptions.common.InternalServerErrorException;
   6  
import com.dev.education_nearby_server.exceptions.common.ValidationException;
   7  
import com.dev.education_nearby_server.exceptions.common.UnauthorizedException;
   8  
import com.dev.education_nearby_server.models.dto.response.ExceptionResponse;
   9  

  10  
import com.dev.education_nearby_server.utils.ApiExceptionParser;
  11  
import jakarta.validation.ConstraintViolationException;
  12  
import org.springframework.http.ResponseEntity;
  13  
import org.springframework.http.HttpHeaders;
  14  
import org.springframework.http.HttpStatusCode;
  15  
import org.springframework.http.HttpStatus;
  16  
import org.springframework.context.support.DefaultMessageSourceResolvable;
  17  
import org.springframework.validation.BindException;
  18  
import org.springframework.web.bind.MethodArgumentNotValidException;
  19  
import org.springframework.security.authentication.BadCredentialsException;
  20  
import org.springframework.security.authentication.InternalAuthenticationServiceException;
  21  
import org.springframework.dao.DataIntegrityViolationException;
  22  
import org.springframework.transaction.TransactionException;
  23  
import org.springframework.util.StringUtils;
  24  
import org.springframework.web.bind.annotation.ControllerAdvice;
  25  
import org.springframework.web.bind.annotation.ExceptionHandler;
  26  
import org.springframework.web.context.request.WebRequest;
  27  
import org.springframework.web.server.ResponseStatusException;
  28  
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
  29  
import java.time.LocalDateTime;
  30  

  31  
@ControllerAdvice
  32  
public class CustomExceptionHandler extends ResponseEntityExceptionHandler {
  33  
    @ExceptionHandler(ResponseStatusException.class)
  34  
    public ResponseEntity<ExceptionResponse> handleResponseStatusExceptions(ResponseStatusException exception) {
  35  
        int code = exception.getStatusCode().value();
  36  
        HttpStatus status = HttpStatus.resolve(code);
  37  

  38  
        ExceptionResponse body = ExceptionResponse.builder()
  39  
                .dateTime(LocalDateTime.now())
  40  
                .message(exception.getReason() != null ? exception.getReason() : exception.getMessage())
  41  
                .status(status)
  42  
                .statusCode(code)
  43  
                .build();
  44  

  45  
        return ResponseEntity
  46  
                .status(exception.getStatusCode())
  47  
                .body(body);
  48  
    }
  49  

  50  
    @ExceptionHandler(RuntimeException.class)
  51  
    public ResponseEntity<ExceptionResponse> handleRuntimeExceptions(RuntimeException exception) {
  52  
        return handleApiExceptions(new InternalServerErrorException());
  53  
    }
  54  

  55  
    @ExceptionHandler(InternalAuthenticationServiceException.class)
  56  
    public ResponseEntity<ExceptionResponse> handleInternalAuthServiceExceptions(InternalAuthenticationServiceException exception) {
  57  
        Throwable cause = exception.getCause();
  58  

  59  
        if (cause instanceof ApiException) {
  60  
            return handleApiExceptions((ApiException) cause);
  61  
        }
  62  

  63  
        return handleRuntimeExceptions(exception);
  64  
    }
  65  

  66  
    @ExceptionHandler(BadCredentialsException.class)
  67  
    public ResponseEntity<ExceptionResponse> handleBadCredentialsExceptions() {
  68  
        return handleApiExceptions(new UnauthorizedException("Invalid credentials!"));
  69  
    }
  70  

  71  
    @ExceptionHandler(org.springframework.security.access.AccessDeniedException.class)
  72  
    public ResponseEntity<ExceptionResponse> handleAccessDeniedExceptions() {
  73  
        return handleApiExceptions(new AccessDeniedException());
  74  
    }
  75  

  76  
    @ExceptionHandler(ApiException.class)
  77  
    public ResponseEntity<ExceptionResponse> handleApiExceptions(ApiException exception) {
  78  
        ExceptionResponse apiException = ApiExceptionParser.parseException(exception);
  79  

  80  
        return ResponseEntity
  81  
                .status(apiException.getStatus())
  82  
                .body(apiException);
  83  
    }
  84  

  85  
    @ExceptionHandler(TransactionException.class)
  86  
    public ResponseEntity<ExceptionResponse> handleTransactionExceptions(org.springframework.transaction.TransactionException exception) {
  87  
        if (exception.getRootCause() instanceof ConstraintViolationException) {
  88  
            return handleConstraintValidationExceptions((ConstraintViolationException) exception.getRootCause());
  89  
        }
  90  

  91  
        return handleRuntimeExceptions(exception);
  92  
    }
  93  

  94  
    @ExceptionHandler(ConstraintViolationException.class)
  95  
    public ResponseEntity<ExceptionResponse> handleConstraintValidationExceptions(ConstraintViolationException exception) {
  96  
        return handleApiExceptions(new ValidationException(exception.getConstraintViolations()));
  97  
    }
  98  

  99  
    @ExceptionHandler(DataIntegrityViolationException.class)
 100  
    public ResponseEntity<ExceptionResponse> handleDataIntegrityViolation(DataIntegrityViolationException exception) {
 101  
        String message = prettyDataIntegrityMessage(exception);
 102  
        return handleApiExceptions(new com.dev.education_nearby_server.exceptions.common.ConflictException(message));
 103  
    }
 104  

 105  
    @Override
 106  
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
 107  
            MethodArgumentNotValidException ex,
 108  
            HttpHeaders headers,
 109  
            HttpStatusCode status,
 110  
            WebRequest request) {
 111  
        String message = ex.getBindingResult()
 112  
                .getAllErrors()
 113  
                .stream()
 114  
                .map(DefaultMessageSourceResolvable::getDefaultMessage)
 115  
                .reduce((a, b) -> a + "\n" + b)
 116  
                .orElse("Validation failed");
 117  

 118  
        ResponseEntity<ExceptionResponse> resp = handleApiExceptions(new ValidationException(message));
 119  
        return ResponseEntity.status(resp.getStatusCode()).body(resp.getBody());
 120  
    }
 121  

 122  
    @Override
 123  
    protected ResponseEntity<Object> handleBindException(
 124  
            BindException ex,
 125  
            HttpHeaders headers,
 126  
            HttpStatusCode status,
 127  
            WebRequest request) {
 128  
        String message = ex.getBindingResult()
 129  
                .getAllErrors()
 130  
                .stream()
 131  
                .map(DefaultMessageSourceResolvable::getDefaultMessage)
 132  
                .reduce((a, b) -> a + "\n" + b)
 133  
                .orElse("Validation failed");
 134  

 135  
        ResponseEntity<ExceptionResponse> resp = handleApiExceptions(new ValidationException(message));
 136  
        return ResponseEntity.status(resp.getStatusCode()).body(resp.getBody());
 137  
    }
 138  

 139  
    private String prettyDataIntegrityMessage(DataIntegrityViolationException ex) {
 140  
        Throwable cause = ex.getMostSpecificCause() != null ? ex.getMostSpecificCause() : ex;
 141  
        String raw = cause.getMessage();
 142  
        if (!StringUtils.hasText(raw)) {
 143  
            raw = ex.getMessage();
 144  
        }
 145  
        if (!StringUtils.hasText(raw)) {
 146  
            return "Data integrity violation";
 147  
        }
 148  

 149  
        String lower = raw.toLowerCase();
 150  

 151  
        // PostgreSQL
 152  
        if (lower.contains("duplicate key value violates unique constraint")) {
 153  
            String key = null;
 154  
            int p = lower.indexOf("unique constraint ");
 155  
            if (p >= 0) {
 156  
                int start = raw.indexOf('"', p);
 157  
                if (start >= 0) {
 158  
                    int end = raw.indexOf('"', start + 1);
 159  
                    if (end > start) {
 160  
                        key = raw.substring(start + 1, end);
 161  
                    }
 162  
                }
 163  
            }
 164  
            String mapped = mapUniqueKeyToFieldMessage(key);
 165  
            return mapped != null ? mapped : "Duplicate key value violates unique constraint";
 166  
        }
 167  

 168  
        // MySQL/MariaDB
 169  
        if (lower.contains("duplicate entry")) {
 170  
            String key = extractBetween(raw, "for key '", "'");
 171  
            String mapped = mapUniqueKeyToFieldMessage(key);
 172  
            return mapped != null ? mapped : "Duplicate entry for unique key";
 173  
        }
 174  

 175  
        // H2
 176  
        if (lower.contains("unique index") || lower.contains("primary key violation")) {
 177  
            String cols = extractBetween(raw, "(", ")");
 178  
            String mapped = mapUniqueKeyToFieldMessage(cols);
 179  
            return mapped != null ? mapped : "Unique index or primary key violation";
 180  
        }
 181  

 182  
        return "Data integrity violation";
 183  
    }
 184  

 185  
    private String extractBetween(String text, String start, String end) {
 186  
        if (text == null) return null;
 187  
        int i = text.indexOf(start);
 188  
        if (i < 0) return null;
 189  
        i += start.length();
 190  
        int j = text.indexOf(end, i);
 191  
        if (j < 0) return null;
 192  
        return text.substring(i, j);
 193  
    }
 194  

 195  
    private String mapUniqueKeyToFieldMessage(String keyOrCols) {
 196  
        if (!StringUtils.hasText(keyOrCols)) return null;
 197  
        String k = keyOrCols.toLowerCase();
 198  
        if (k.contains("email")) {
 199  
            return "User with such email already exists!";
 200  
        }
 201  
        if (k.contains("username") || k.contains("user_name")) {
 202  
            return "User with such username already exists!";
 203  
        }
 204  
        return null;
 205  
    }
 206  
}
